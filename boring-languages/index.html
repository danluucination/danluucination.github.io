<!DOCTYPE html><html lang=en><meta charset=utf-8><title>A defense of boring languages</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><link rel="stylesheet" href="/styles.css"></style><link rel=icon href="data:;base64,="> <header><strong>A defense of boring languages</strong> | <a href=https://patreon.com/danluu>Patreon</a><hr></header><main> <p>Boring languages are underrated. Many appear to be rated quite highly, at least if you look at market share. But even so, they're underrated. Despite the popularity of Dan McKinley's <a href=https://mcfunley.com/choose-boring-technology>&quot;choose boring technology&quot;</a> essay, boring languages are widely panned. People who use them are too (e.g., they're a target of essays by Paul Graham and Joel Spolsky, <a href="https://news.ycombinator.com/item?id=2379259">and other people have picked up a similar attitude</a>).</p> <p>A commonly used pitch for interesting languages goes something like &quot;Sure, you can get by with writing blub for boring work, which almost all programmers do, but if you did interesting work, then you'd want to use an interesting language&quot;. My feeling is that this has it backwards. When I'm doing boring work that's basically bottlenecked on the speed at which I can write boilerplate, it feels much nicer to use an interesting language (like F#), which lets me cut down on the amount of time spent writing boilerplate. But when I'm doing interesting work, the boilerplate is a rounding error and I don't mind using a boring language like Java, even if that means a huge fraction of the code I'm writing is boilerplate.</p> <p>Another common pitch, similar to the above, is that learning interesting languages will teach you new ways to think that will make you a much more effective programmer<sup class=footnote-ref id=fnref:S><a rel=footnote href=#fn:S>1</a></sup>. I can't speak for anyone else, but I found that line of reasoning compelling when I was early in my career and learned ACL2 (a Lisp), Forth, F#, etc.; enough of it stuck that I still love F#. But, despite taking the advice that &quot;learning a wide variety of languages that support different programming paradigms will change how you think&quot; seriously, my experience has been that the things I've learned mostly let me crank through boilerplate more efficiently. While that's pretty great when I have a boilerplate-constrained problem, when I have a hard problem, I spend so little time on that kind of stuff that the skills I learned from writing a wide variety of languages don't really help me; instead, what helps me is having domain knowledge that gives me a good lever with which I can solve the hard problem. This explains something I'd wondered about when I finished grad school and arrived in the real world: why is it that the programmers who build the systems I find most impressive typically have deep domain knowledge rather than interesting language knowledge?</p> <p>Another perspective on this is Sutton's response when asked why he robbed banks, &quot;because that's where the money is&quot;. Why do I work in boring languages? Because that's what the people I want to work with use, and what the systems I want to work on are written in. The vast majority of the systems I'm interested in are writing in boring languages. Although that technically doesn't imply that the vast majority of people I want to work with primarily use and have their language expertise in boring languages, that also turns out to be the case in practice. That means that, for greenfield work, it's also likely that the best choice will be a boring language. I think F# is great, but I wouldn't choose it over working with the people I want to work with on the problems that I want to work on.</p> <p>If I look at the list of things I'm personally impressed with (things like Spanner, BigTable, Colossus, etc.), it's basically all C++, with almost all of the knockoffs in Java. When I think for a minute, the list of software written in C, C++, and Java is really pretty long. Among the transitive closure of things I use and the libraries and infrastructure used by those things, those three languages are ahead by a country mile, with PHP, Ruby, and Python rounding out the top 6. Javascript should be in there somewhere if I throw in front-end stuff, but it's so ubiquitous that making a list seems a bit pointless.</p> <p>Below are some lists of software written in boring languages. These lists are long enough that I’m going to break them down into some arbitrary sublists. As is often the case, these aren’t really nice orthogonal categories and should be tags, but here we are. In the lists below, apps are categorized under “Backend” based on the main language used on the backend of a webapp. The other categories are pretty straightforward, even if their definitions a bit idiosyncratic and perhaps overly broad.</p> <h2 id=c>C</h2> <h3 id=operating-systems>Operating Systems</h3> <p>Linux, including variants like KindleOS<br> BSD<br> Darwin (with C++)<br> <a href=http://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs>Plan 9</a><br> Windows (kernel in C, with some C++ elsewhere)</p> <h3 id=platforms-infrastructure>Platforms/Infrastructure</h3> <p><a href=http://en.wikipedia.org/wiki/Memcached>Memcached</a><br> <a href=https://www.sqlite.org/index.html>SQLite</a><br> <a href=http://en.wikipedia.org/wiki/Nginx>nginx</a><br> <a href=http://en.wikipedia.org/wiki/Apache_HTTP_Server>Apache</a><br> <a href=http://en.wikipedia.org/wiki/IBM_DB2>DB2</a><br> <a href=http://en.wikipedia.org/wiki/PostgreSQL>PostgreSQL</a><br> <a href=https://aphyr.com/posts/307-call-me-maybe-redis-redux>Redis</a><br> <a href=http://en.wikipedia.org/wiki/Varnish_%28software%29>Varnish</a><br> <a href=http://en.wikipedia.org/wiki/HAProxy>HAProxy</a> AWS Lambda workers (with most of the surrounding infrastructure written in Java), according to @jayachdee</p> <h3 id=desktop-apps>Desktop Apps</h3> <p>git<br> Gimp (with perl)<br> VLC<br> Qemu<br> OpenGL<br> <a href=http://en.wikipedia.org/wiki/FFmpeg>FFmpeg</a><br> Most GNU userland tools<br> Most BSD userland tools<br> <a href=http://lcamtuf.coredump.cx/afl/ >AFL</a><br> Emacs<br> Vim</p> <h2 id=c-1>C++</h2> <h3 id=operating-systems-1>Operating Systems</h3> <p>BeOS/<a href=http://en.wikipedia.org/wiki/Haiku_%28operating_system%29>Haiku</a></p> <h3 id=platforms-infrastructure-1>Platforms/Infrastructure</h3> <p><a href=http://research.google.com/archive/gfs.html>GFS</a><br> <a href=http://www.wired.com/2012/07/google-colossus/ >Colossus</a><br> <a href=http://en.wikipedia.org/wiki/Ceph_%28software%29>Ceph</a><br> <a href=http://research.google.com/pubs/pub36632.html>Dremel</a><br> <a href=http://research.google.com/archive/chubby.html>Chubby</a><br> <a href=http://research.google.com/archive/bigtable.html>BigTable</a><br> <a href=http://research.google.com/archive/spanner.html>Spanner</a><br> <a href=http://en.wikipedia.org/wiki/MySQL>MySQL</a><br> <a href=http://en.wikipedia.org/wiki/%C3%98MQ>ZeroMQ</a><br> <a href=https://github.com/scylladb/scylla>ScyllaDB</a><br> <a href=https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads>MongoDB</a><br> <a href=http://en.wikipedia.org/wiki/Apache_Mesos>Mesos</a><br> <a href=http://en.wikipedia.org/wiki/Java_virtual_machine>JVM</a><br> <a href=http://en.wikipedia.org/wiki/.NET_Framework>.NET</a></p> <h3 id=backend-apps>Backend Apps</h3> <p>Google Search<br> PayPal<br> Figma (<a href=https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/ >front-end written in C++ and cross-compiled to JS</a>)</p> <h3 id=desktop-apps-1>Desktop Apps</h3> <p>Chrome<br> MS Office<br> LibreOffice (with Java)<br> Evernote (originally in C#, converted to C++)<br> Firefox<br> Opera<br> Visual Studio (with C#)<br> Photoshop, Illustrator, InDesign, etc.<br> gcc<br> llvm/clang<br> Winamp<br> <a href=https://github.com/z3prover/z3/wiki>Z3</a><br> Most AAA games<br> Most pro audio and video production apps</p> <h3 id=elsewhere>Elsewhere</h3> <p>Also see <a href=http://www.stroustrup.com/applications.html>this list</a> and <a href=https://isocpp.org/wiki/faq/big-picture#who-uses-cpp>some of the links here</a>.</p> <h2 id=java>Java</h2> <h3 id=platforms-infrastructure-2>Platforms/Infrastructure</h3> <p><a href=http://en.wikipedia.org/wiki/Apache_Hadoop>Hadoop</a><br> <a href=http://www.aosabook.org/en/hdfs.html>HDFS</a><br> <a href=http://en.wikipedia.org/wiki/Apache_ZooKeeper>Zookeeper</a><br> <a href=http://techblog.netflix.com/2014/10/using-presto-in-our-big-data-platform.html>Presto</a><br> <a href=https://aphyr.com/posts/294-call-me-maybe-cassandra/ >Cassandra</a><br> <a href=https://aphyr.com/posts/323-call-me-maybe-elasticsearch-1-5-0>Elasticsearch</a><br> <a href=https://en.wikipedia.org/wiki/Lucene>Lucene</a><br> <a href=http://en.wikipedia.org/wiki/Apache_Tomcat>Tomcat</a><br> <a href=http://en.wikipedia.org/wiki/Jetty_(web_server)>Jetty</a></p> <h3 id=backend-apps-1>Backend Apps</h3> <p>Gmail<br> LinkedIn<br> <a href=http://www.theregister.co.uk/2007/11/12/ebay_glitches/ >Ebay</a><br> <a href=http://silvaetechnologies.eu/blg/50/the-majority-of-netflix-services-are-built-on-java>Most of Netflix</a><br> A large fraction of Amazon services</p> <h3 id=desktop-apps-2>Desktop Apps</h3> <p><a href=http://en.wikipedia.org/wiki/IBM_VisualAge>Eclipse</a><br> JetBrains IDEs<br> SmartGit<br> <a href=http://en.wikipedia.org/wiki/Minecraft>Minecraft</a></p> <h1 id=vhdl-verilog>VHDL/Verilog</h1> <p>I'm not even going to make a list because basically every major microprocessor, NIC, switch, etc. is made in either VHDL or Verilog. For existing projects, you might say that this is because you have a large team that's familiar with some boring language, but I've worked on greenfield hardware/software co-design for deep learning and networking virtualization, both with teams that are hired from scratch for the project, and we still used Verilog, despite one of the teams having one of the larger collections of bluespec proficient hardware engineers anywhere outside of Arvind's group at MIT.</p> <p><a href=https://twitter.com/danluu>Please suggest</a> other software that you think belongs on this list; it doesn't have to be software that I personally use. Also, does anyone know what EC2, S3, and Redshift are written in? I suspect C++, but I couldn't find a solid citation for that. This post was last updated 2021-08.</p> <h2 id=appendix-meta>Appendix: meta</h2> <p>One thing I find interesting is that, in personal conversations with people, the vast majority of experienced developers I know think that most mainstream languages are basically fine, modulo performance constraints, and this is even more true among people who've built systems that are really impressive to me. Online discussion of what someone might want to learn is very different, with learning interesting/fancy languages being generally high up on people's lists. When I talk to new programmers, they're often pretty influenced by this (e.g., at Recurse Center, before ML became trendy, learning fancy languages was the most popular way people tried to become better as a programmer, and I'd say that's now #2 behind ML). While I think learning a fancy language does work for some people, I'd say that's overrated in that there are many other techniques that seem to click with at least the same proportion of people who try it that are much less popular.</p> <p>A question I have is, why is online discussion about this topic so one-sided while the discussions I've had in real life are so oppositely one-sided. Of course, neither people who are loud on the internet nor people I personally know are representative samples of programmers, but I still find it interesting.</p> <p><small> Thanks to Leah Hanson, James Porter, Waldemar Q, Nat Welch, Arjun Sreedharan, Rafa Escalante, @matt_dz, Bartlomiej Filipek, Josiah Irwin, @jayachdee, Larry Ogrondek, Miodrag Milic, Presto, Matt Godbolt, Leah Hanson, Noah Haasis, Lifan Zeng, @chozu@fedi.absturztau.be, and Josiah Irwin for comments/corrections/discussion. </small></p> <div class=footnotes> <hr> <ol> <li id=fn:S>a variant of this argument goes beyond teaching you techniques and says that the languages you know determine what you think via the Sapir-Whorf hypothesis. I don't personally find this compelling since, when I'm solving hard problems, I don't think about things in a programming language. YMMV if you think in a programming language, but I think of an abstract solution and then translate the solution to a language, so having another language in my toolbox can, at most, help me think of better translations and save on translation. <a class=footnote-return href=#fnref:S><sup>[return]</sup></a></li> </ol> </div> </main><nav><div class=np> <a href=googlebot-monopoly/ >← The googlebot monopoly</a> <a href=monorepo/ >Advantages of monorepos →</a> </div></nav> <footer><div class=np> <a href= >Archive</a> <a href=https://mastodon.social/@danluu>Mastodon</a> <a href=https://threads.net/@danluu.danluu>Threads</a> </div> <div class=np> <a href=https://www.patreon.com/danluu>Patreon</a> <a href=https://www.linkedin.com/in/danluu/ >LinkedIn</a> <a href=https://twitter.com/danluu/ >Twitter</a> <a href=atom.xml>RSS</a></div></footer> 