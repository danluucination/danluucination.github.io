<!doctypehtml><html lang=en><meta charset=utf-8><title>Sattolo&#39;s algorithm</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><link rel="stylesheet" href="/styles.css"></style><link rel=icon href="data:;base64,="> <header><strong>Sattolo&#39;s algorithm</strong> | <a href=https://patreon.com/danluu>Patreon</a><hr></header><main> <p>I recently had a problem where part of the solution was to do a series of pointer accesses that would walk around a chunk of memory in pseudo-random order. Sattolo's algorithm provides a solution to this because it produces a permutation of a list with exactly one cycle, which guarantees that we will reach every element of the list even though we're traversing it in random order.</p> <p>However, the explanations of why the algorithm worked that I could find online either used some kind of mathematical machinery (Stirling numbers, assuming familiarity with cycle notation, etc.), or used logic that was hard for me to follow. I find that this is common for explanations of concepts that could, but don't have to, use a lot of mathematical machinery. I don't think there's anything wrong with using existing mathematical methods per se -- it's a nice mental shortcut if you're familiar with the concepts. If you're taking a combinatorics class, it makes sense to cover Stirling numbers and then rattle off a series of results whose proofs are trivial if you're familiar with Stirling numbers, but for people who are only interested in a single result, I think it's unfortunate that it's hard to find a relatively simple explanation that <a href=https://twitter.com/danluu/status/1147984717238562816>doesn't require any background</a>. When I was looking for a simple explanation, I also found a lot of people who were using Sattolo's algorithm in places where it wasn't appropriate and also people who didn't know that Sattolo's algorithm is what they were looking for, so here's an attempt at an explanation of why the algorithm works that doesn't assume an undergraduate combinatorics background.</p> <p>Before we look at Sattolo's algorithm, let's look at Fisher-Yates, which is an <a href=https://en.wikipedia.org/wiki/In-place_algorithm>in-place</a> algorithm that produces a random permutation of an array/vector, where every possible permutation occurs with uniform probability.</p> <p>We'll look at the code for Fisher-Yates and then how to prove that the algorithm produces the intended result.</p> <pre><code>def shuffle(a):
    n = len(a)
    for i in range(n - 1):  # i from 0 to n-2, inclusive.
        j = random.randrange(i, n)  # j from i to n-1, inclusive.
        a[i], a[j] = a[j], a[i]  # swap a[i] and a[j].
</code></pre> <p><code>shuffle</code> takes an array and produces a permutation of the array, i.e., it shuffles the array. We can think of this loop as placing each element of the array, <code>a</code>, in turn, from <code>a[0]</code> to <code>a[n-2]</code>. On some iteration, <code>i</code>, we choose one of <code>n-i</code> elements to swap with and swap element <code>i</code> with some random element. The last element in the array, <code>a[n-1]</code>, is skipped because it would always be swapped with itself. One way to see that this produces every possible permutation with uniform probability is to write down the probability that each element will end up in any particular location<sup class=footnote-ref id=fnref:P><a rel=footnote href=#fn:P>1</a></sup>. Another way to do it is to observe two facts about this algorithm:</p> <ol> <li>Every output that Fisher-Yates produces is produced with uniform probability</li> <li>Fisher-Yates produces as many outputs as there are permutations (and each output is a permutation)</li> </ol> <p>(1) For each random choice we make in the algorithm, if we make a different choice, we get a different output. For example, if we look at the resultant <code>a[0]</code>, the only way to place the element that was originally in <code>a[k]</code> (for some <code>k</code>) in the resultant <code>a[0]</code> is to swap <code>a[0]</code> with <code>a[k]</code> in iteration <code>0</code>. If we choose a different element to swap with, we'll end up with a different resultant <code>a[0]</code>. Once we place <code>a[0]</code> and look at the resultant <code>a[1]</code>, the same thing is true of <code>a[1]</code> and so on for each <code>a[i]</code>. Additionally, each choice reduces the range by the same amount -- there's a kind of symmetry, in that although we place <code>a[0]</code> first, we could have placed any other element first; every choice has the same effect. This is vaguely analogous to the reason that you can pick an integer uniformly at random by picking digits uniformly at random, one at a time.</p> <p>(2) How many different outputs does Fisher-Yates produce? On the first iteration, we fix one of <code>n</code> possible choices for <code>a[0]</code>, then given that choice, we fix one of <code>n-1</code> choices for <code>a[1]</code>, then one of <code>n-2</code> for <code>a[2]</code>, and so on, so there are <code>n * (n-1) * (n-2) * ... 2 * 1 = n!</code> possible different outputs.</p> <p>This is exactly the same number of possible permutations of <code>n</code> elements, by pretty much the same reasoning. If we want to count the number of possible permutations of <code>n</code> elements, we first pick one of <code>n</code> possible elements for the first position, <code>n-1</code> for the second position, and so on resulting in <code>n!</code> possible permutations.</p> <p>Since Fisher-Yates only produces unique permutations and there are exactly as many outputs as there are permutations, Fisher-Yates produces every possible permutation. Since Fisher-Yates produces each output with uniform probability, it produces all possible permutations with uniform probability.</p> <p>Now, let's look at Sattolo's algorithm, which is almost identical to Fisher-Yates and also produces a shuffled version of the input, but produces something quite different:</p> <pre><code>def sattolo(a):
    n = len(a)
    for i in range(n - 1):
        j = random.randrange(i+1, n)  # i+1 instead of i
        a[i], a[j] = a[j], a[i]
</code></pre> <p>Instead of picking an element at random to swap with, like we did in Fisher-Yates, we pick an element at random that is not the element being placed, i.e., we do not allow an element to be swapped with itself. One side effect of this is that no element ends up where it originally started.</p> <p>Before we talk about why this produces the intended result, let's make sure we're on the same page regarding terminology. One way to look at an array is to view it as a description of a graph where the index indicates the node and the value indicates where the edge points to. For example, if we have the list <code>0 2 3 1</code>, this can be thought of as a directed graph from its indices to its value, which is a graph with the following edges:</p> <pre><code>0 -&gt; 0
1 -&gt; 2
2 -&gt; 3
3 -&gt; 1
</code></pre> <p>Node 0 points to itself (because the value at index 0 is 0), node 1 points to node 2 (because the value at index 1 is 2), and so on. If we traverse this graph, we see that there are two cycles. <code>0 -&gt; 0 -&gt; 0 ...</code> and <code>1 -&gt; 2 -&gt; 3 -&gt; 1...</code>.</p> <p>Let's say we swap the element in position 0 with some other element. It could be any element, but let's say that we swap it with the element in position 2. Then we'll have the list <code>3 2 0 1</code>, which can be thought of as the following graph:</p> <pre><code>0 -&gt; 3
1 -&gt; 2
2 -&gt; 0
3 -&gt; 1
</code></pre> <p>If we traverse this graph, we see the cycle <code>0 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 0...</code>. This is an example of a permutation with exactly one cycle.</p> <p>If we swap two elements that belong to different cycles, we'll merge the two cycles into a single cycle. One way to see this is when we swap two elements in the list, we're essentially picking up the arrow-heads pointing to each element and swapping where they point (rather than the arrow-tails, which stay put). Tracing the result of this is like tracing a figure-8. Just for example, say if we swap <code>0</code> with an arbitrary element of the other cycle, let's say element 2, we'll end up with <code>3 2 0 1</code>, whose only cycle is <code>0 -&gt; 3 -&gt; 1 -&gt; 2 -&gt; 0...</code>. Note that this operation is reversible -- if we do the same swap again, we end up with two cycles again. In general, if we swap two elements from the same cycle, we break the cycle into two separate cycles.</p> <p>If we feed a list consisting of <code>0 1 2 ... n-1</code> to Sattolo's algorithm we'll get a permutation with exactly one cycle. Furthermore, we have the same probability of generating any permutation that has exactly one cycle. Let's look at why Sattolo's generates exactly one cycle. Afterwards, we'll figure out why it produces all possible cycles with uniform probability.</p> <p>For Sattolo's algorithm, let's say we start with the list <code>0 1 2 3 ... n-1</code>, i.e., a list with <code>n</code> cycles of length <code>1</code>. On each iteration, we do one swap. If we swap elements from two separate cycles, we'll merge the two cycles, reducing the number of cycles by 1. We'll then do <code>n-1</code> iterations, reducing the number of cycles from <code>n</code> to <code>n - (n-1) = 1</code>.</p> <p>Now let's see why it's safe to assume we always swap elements from different cycles. In each iteration of the algorithm, we swap some element with index &gt; <code>i</code> with the element at index <code>i</code> and then increment <code>i</code>. Since <code>i</code> gets incremented, the element that gets placed into index <code>i</code> can never be swapped again, i.e., each swap puts one of the two elements that was swapped into its final position, i.e., for each swap, we take two elements that were potentially swappable and render one of them unswappable.</p> <p>When we start, we have <code>n</code> cycles of length <code>1</code>, each with <code>1</code> element that's swappable. When we swap the initial element with some random element, we'll take one of the swappable elements and render it unswappable, creating a cycle of length <code>2</code> with <code>1</code> swappable element and leaving us with <code>n-2</code> other cycles, each with <code>1</code> swappable element.</p> <p>The key invariant that's maintained is that each cycle has exactly <code>1</code> swappable element. The invariant holds in the beginning when we have <code>n</code> cycles of length <code>1</code>. And as long as this is true, every time we merge two cycles of any length, we'll take the swappable element from one cycle and swap it with the swappable element from the other cycle, rendering one of the two elements unswappable and creating a longer cycle that still only has one swappable element, maintaining the invariant.</p> <p>Since we cannot swap two elements from the same cycle, we merge two cycles with every swap, reducing the number of cycles by 1 with each iteration until we've run <code>n-1</code> iterations and have exactly one cycle remaining.</p> <p>To see that we generate each cycle with equal probability, note that there's only one way to produce each output, i.e., changing any particular random choice results in a different output. In the first iteration, we randomly choose one of <code>n-1</code> placements, then <code>n-2</code>, then <code>n-3</code>, and so on, so for any particular cycle, we produce it with probability <code>(n-1) * (n-2) * (n-3) ... * 2 * 1 = (n-1)!</code>. If we can show that there are <code>(n-1)!</code> permutations with exactly one cycle, then we'll know that we generate every permutation with exactly one cycle with uniform probability.</p> <p>Let's say we have an arbitrary list of length <code>n</code> that has exactly one cycle and we add a single element, there are <code>n</code> ways to extend that to become a cycle of length <code>n+1</code> because there are <code>n</code> places we could add in the new element and keep the cycle, which means that the number of cycles of length <code>n+1</code>, <code>cycles(n+1)</code>, is <code>n * cycles(n)</code>.</p> <p>For example, say we have a cycle that produces the path <code>0 -&gt; 1 -&gt; 2 -&gt; 0 ...</code> and we want to add a new element, <code>3</code>. We can substitute <code>-&gt; 3 -&gt;</code> for any <code>-&gt;</code> and get a cycle of length 4 instead of length 3.</p> <p>In the base case, there's one cycle of length 2, the permutation <code>1 0</code> (the other permutation of length two, <code>0 1</code>, has two cycles of length one instead of having a cycle of length 2), so we know that <code>cycles(2) = 1</code>. If we apply <a href=https://en.wikipedia.org/wiki/Recurrence_relation>the recurrence above</a>, we get that <code>cycles(n) = (n-1)!</code>, which is exactly the number of different permutations that Sattolo's algorithm generates, which means that we generate all possible permutations with one cycle. Since we know that we generate each cycle with uniform probability, we now know that we generate all possible one-cycle permutations with uniform probability.</p> <p>An alternate way to see that there are <code>(n-1)!</code> permutations with exactly one cycle, is that we rotate each cycle around so that <code>0</code> is at the start and write it down as <code>0 -&gt; i -&gt; j -&gt; k -&gt; ...</code>. The number of these is the same as the number of permutations of elements to the right of the <code>0 -&gt;</code>, which is <code>(n-1)!</code>.</p> <h3 id=conclusion>Conclusion</h3> <p>We've looked at two algorithms that are identical, except for a two character change. These algorithms produce quite different results -- one algorithm produces a random permutation and the other produces a random permutation with exactly one cycle. I think these algorithms are neat because they're so simple, just a double for loop with a swap.</p> <p>In practice, you probably don't &quot;need&quot; to know how these algorithms work because the standard library for most modern languages will have some way of producing a random shuffle. And if you have a function that will give you a shuffle, you can produce a permutation with exactly one cycle if you don't mind a non-in-place algorithm that takes an extra pass. I'll leave that as an exercise for the reader, but if you want a hint, one way to do it parallels the &quot;alternate&quot; way to see that there are <code>(n-1)!</code> permutations with exactly one cycle.</p> <p>Although I said that you probably don't need to know this stuff, you do actually need to know it if you're going to implement a custom shuffling algorithm! That may sound obvious, but there's a long history of people implementing incorrect shuffling algorithms. This was common in games and on <a href=http://www.datamation.com/entdev/article.php/616221/How-We-Learned-to-Cheat-at-Online-Poker-A-Study-in-Software-Security.htm>online gambling sites in the 90s and even the early 2000s</a> and you still see the occasional mis-implemented shuffle, e.g., when <a href=http://www.robweir.com/blog/2010/02/microsoft-random-browser-ballot.html>Microsoft implemented a bogus shuffle and failed to properly randomize a browser choice poll</a>. At the time, the top Google hit for <code>javascript random array sort</code> was <a href=https://web.archive.org/web/20100102004604/http://www.javascriptkit.com/javatutors/arraysort.shtml>the incorrect algorithm that Microsoft ended up using</a>. That site has been fixed, but you can still find incorrect tutorials floating around online.</p> <h4 id=appendix-generating-a-random-derangement>Appendix: generating a random derangement</h4> <p>A permutation where no element ends up in its original position is called a derangement. When I searched for uses of Sattolo's algorithm, I found many people using Sattolo's algorithm to generate random derangements. While Sattolo's algorithm generates derangements, it only generates derangements with exactly one cycle, and there are derangements with more than one cycle (e.g., <code>3 2 1 0</code>), so it can't possibly generate random derangements with uniform probability.</p> <p>One way to generate random derangements is to generate random shuffles using Fisher-Yates and then retry until we get a derangement:</p> <pre><code>def derangement(n):
    assert n != 1, &quot;can't have a derangement of length 1&quot;
    a = list(range(n))
    while not is_derangement(a):
        shuffle(a)
    return a
</code></pre> <p>This algorithm is simple, and is overwhelmingly likely to eventually return a derangement (for n != 1), but it's not immediately obvious how long we should expect this to run before it returns a result. Maybe we'll get a derangement on the first try and run <code>shuffle</code> once, or maybe it will take 100 tries and we'll have to do 100 shuffles before getting a derangement.</p> <p>To figure this out, we'll want to know the probability that a random permutation (shuffle) is a derangement. To get that, we'll want to know, given a list of of length <code>n</code>, how many permutations there are and how many derangements there are.</p> <p>Since we're deep in the appendix, I'll assume that you know <a href=https://en.wikipedia.org/wiki/Permutation>the number of permutations of a n elements is <code>n!</code></a> what <a href=https://en.wikipedia.org/wiki/Binomial_coefficient>binomial coefficients</a> are, and are comfortable with <a href=https://en.wikipedia.org/wiki/Taylor_series>Taylor series</a>.</p> <p>To count the number of derangements, we can start with the number of permutations, <code>n!</code>, and subtract off permutations where an element remains in its starting position, <code>(n choose 1) * (n - 1)!</code>. That isn't quite right because this double subtracts permutations where two elements remain in the starting position, so we'll have to add back <code>(n choose 2) * (n - 2)!</code>. That isn't quite right because we've overcorrected elements with three permutations, so we'll have to add those back, <a href=https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle>and so on and so forth</a>, resulting in <code>∑ (−1)ᵏ (n choose k)(n−k)!</code>. If we expand this out and divide by <code>n!</code> and cancel things out, we get <code>∑ (−1)ᵏ (1 / k!)</code>. If we look at the limit as the number of elements goes to infinity, this looks just like <a href=https://en.wikipedia.org/wiki/Taylor_series>the Taylor series</a> for <code>e^x</code> where <code>x = -1</code>, i.e., <code>1/e</code>, i.e., in the limit, we expect that the fraction of permutations that are derangements is <code>1/e</code>, i.e., we expect to have to do <code>e</code> times as many swaps to generate a derangement as we do to generate a random permutation. Like many alternating series, this series converges quickly. It gets within 7 significant figures of <code>e</code> when <code>k = 10</code>!</p> <p>One silly thing about our algorithm is that, if we place the first element in the first location, we already know that we don't have a derangement, but we continue placing elements until we've created an entire permutation. If we reject illegal placements, we can do even better than a factor of <code>e</code> overhead. It's also possible to come up with <a href=http://mathforum.org/library/drmath/view/61957.html>a non-rejection based algorithm</a>, but I really enjoy the naive rejection based algorithm because I find it delightful when <a href=https://www.cs.princeton.edu/courses/archive/fall13/cos521/lecnotes/lec2final.pdf>basic randomized algorithms that consist of &quot;keep trying again&quot; work well</a>.</p> <h4 id=appendix-wikipedia-s-explanation-of-sattolo-s-algorithm>Appendix: wikipedia's explanation of Sattolo's algorithm</h4> <p>I wrote this explanation because I found <a href=https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle>the explanation in Wikipedia</a> relatively hard to follow, but if you find the explanation above difficult to understand, maybe you'll prefer wikipedia's version:</p> <blockquote> <p>The fact that Sattolo's algorithm always produces a cycle of length n can be shown by induction. Assume by induction that after the initial iteration of the loop, the remaining iterations permute the first n - 1 elements according to a cycle of length n - 1 (those remaining iterations are just Sattolo's algorithm applied to those first n - 1 elements). This means that tracing the initial element to its new position p, then the element originally at position p to its new position, and so forth, one only gets back to the initial position after having visited all other positions. Suppose the initial iteration swapped the final element with the one at (non-final) position k, and that the subsequent permutation of first n - 1 elements then moved it to position l; we compare the permutation π of all n elements with that remaining permutation σ of the first n - 1 elements. Tracing successive positions as just mentioned, there is no difference between σ and π until arriving at position k. But then, under π the element originally at position k is moved to the final position rather than to position l, and the element originally at the final position is moved to position l. From there on, the sequence of positions for π again follows the sequence for σ, and all positions will have been visited before getting back to the initial position, as required.</p> <p>As for the equal probability of the permutations, it suffices to observe that the modified algorithm involves (n-1)! distinct possible sequences of random numbers produced, each of which clearly produces a different permutation, and each of which occurs--assuming the random number source is unbiased--with equal probability. The (n-1)! different permutations so produced precisely exhaust the set of cycles of length n: each such cycle has a unique cycle notation with the value n in the final position, which allows for (n-1)! permutations of the remaining values to fill the other positions of the cycle notation</p> </blockquote> <p><em>Thanks to Mathieu Guay-Paquet, Leah Hanson, Rudi Chen, Kamal Marhubi, Michael Robert Arntzenius, Heath Borders, Shreevatsa R, @chozu@fedi.absturztau.be, and David Turner for comments/corrections/discussion.</em></p> <p><link rel=prefetch href=/ > <link rel=prefetch href=/about/ ></p> <div class=footnotes> <hr> <ol> <li id=fn:P><p><code>a[0]</code> is placed on the first iteration of the loop. Assuming <code>randrange</code> generates integers with uniform probability in the appropriate range, the original <code>a[0]</code> has <code>1/n</code> probability of being swapped with any element (including itself), so the resultant <code>a[0]</code> has a 1/n chance of being any element from the original <code>a</code>, which is what we want.</p> <p><code>a[1]</code> is placed on the second iteration of the loop. At this point, <code>a[0]</code> is some element from the array before it was mutated. Let's call the unmutated array <code>original</code>. <code>a[0]</code> is <code>original[k]</code>, for some <code>k</code>. For any particular value of <code>k</code>, it contains <code>original[k]</code> with probability <code>1/n</code>. We then swap <code>a[1]</code> with some element from the range <code>[1, n-1]</code>.</p> <p>If we want to figure out the probability that <code>a[1]</code> is some particular element from <code>original</code>, we might think of this as follows: <code>a[0]</code> is <code>original[k_0]</code> for some <code>k_0</code>. <code>a[1]</code> then becomes <code>original[k_1]</code> for some <code>k_1</code> where <code>k_1 != k_0</code>. Since <code>k_0</code> was chosen uniformly at random, if we integrate over all <code>k_0</code>, <code>k_1</code> is also uniformly random.</p> <p>Another way to look at this is that it's arbitrary that we place <code>a[0]</code> and choose <code>k_0</code> before we place <code>a[1]</code> and choose <code>k_1</code>. We could just have easily placed <code>a[1]</code> and chosen <code>k_1</code> first so, over all possible choices, the choice of <code>k_0</code> cannot bias the choice of <code>k_1</code>.</p> <a class=footnote-return href=#fnref:P><sup>[return]</sup></a></li> </ol> </div> </main><nav><div class=np> <a href=branch-prediction/ >← Branch prediction</a> <a href=term-latency/ >Terminal latency →</a> </div></nav> <footer><div class=np> <a href= >Archive</a> <a href=https://mastodon.social/@danluu>Mastodon</a> <a href=https://threads.net/@danluu.danluu>Threads</a> </div> <div class=np> <a href=https://www.patreon.com/danluu>Patreon</a> <a href=https://www.linkedin.com/in/danluu/ >LinkedIn</a> <a href=https://twitter.com/danluu/ >Twitter</a> <a href=atom.xml>RSS</a></div></footer> 