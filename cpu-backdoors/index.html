<!doctypehtml><html lang=en><meta charset=utf-8><title>CPU backdoors</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="stylesheet" href="/styles.css"></style><link rel=icon href="data:;base64,="> <header><strong>CPU backdoors</strong> | <a href=https://patreon.com/danluu>Patreon</a><hr></header><main> <p>It's generally accepted that any piece of software could be compromised with a backdoor. Prominent examples include the <a href=http://en.wikipedia.org/wiki/Sony_BMG_copy_protection_rootkit_scandal>Sony/BMG installer</a>, which had a backdoor built-in to allow Sony to keep users from copying the CD, which also allowed malicious third-parties to take over any machine with the software installed; the <a href=http://redmine.replicant.us/projects/replicant/wiki/SamsungGalaxyBackdoor>Samsung Galaxy</a>, which has a backdoor that allowed the modem to access the device's filesystem, which also allows anyone running <a href="https://www.youtube.com/watch?v=RXqQioV_bpo">a fake base station to access files on the device</a>; <a href=http://www.cypherspace.org/adam/hacks/lotus-nsa-key.html>Lotus Notes</a>, which had a backdoor which allowed encryption to be defeated; and <a href=https://forums.lenovo.com/t5/Lenovo-P-Y-and-Z-series/Lenovo-Pre-instaling-adware-spam-Superfish-powerd-by/td-p/1726839>Lenovo laptops</a>, which pushed all web traffic through a proxy (including HTTPS, via a trusted root certificate) in order to push ads, which allowed anyone with the correct key (which was distributed on every laptop) to intercept HTTPS traffic.</p> <p>Despite sightings of backdoors in <a href=http://www.cl.cam.ac.uk/~sps32/sec_news.html#Assurance>FPGAs</a> and <a href=https://github.com/elvanderb/TCP-32764>networking gear</a>, whenever someone brings up the possibility of CPU backdoors, it's still common for people to claim that it's <a href="https://news.ycombinator.com/item?id=6147767">impossible</a>. I'm not going to claim that CPU backdoors exist, but I will claim that the implementation is easy, if you've got the right access.</p>  <p>Let's say you wanted to make a backdoor. How would you do it? There are three parts to this: what could a backdoored CPU do, how could the backdoor be accessed, and what kind of compromise would be required to install the backdoor?</p> <p>Starting with the first item, what does the backdoor do? There are a lot of possibilities. The simplest is to allow privilege escalation: make the CPU to <a href=http://en.wikipedia.org/wiki/Protection_ring>transition from ring3 to ring0 or SMM</a>, giving the running process kernel-level privileges. Since it's the CPU that's doing it, this can punch through both hardware and software virtualization. There are a lot of subtler or more invasive things you could do, but privilege escalation is both simple enough and powerful enough that I'm not going to discuss the other options.</p> <p>Now that you know what you want the backdoor to do, how should it get triggered? Ideally, it will be something that no one will run across by accident, or even by brute force, while looking for backdoors. Even with that limitation, the state space of possible triggers is huge.</p> <p>Let's look at a particular instruction, <code>fyl2x</code><sup class=footnote-ref id=fnref:I><a rel=footnote href=#fn:I>1</a></sup>. Under normal operation, it takes two floating point registers as input, giving you <code>2*80=160</code> bits to hide a trigger in. If you trigger the backdoor off of a specific pair of values, that's probably safe against random discovery. If you're really worried about someone stumbling across the backdoor by accident, or brute forcing a suspected backdoor, you can check more than the two normal input registers (after all, you've got control of the CPU).</p> <p>This trigger is nice and simple, but the downside is that hitting the trigger probably requires executing native code since you're unlikely to get chrome or Firefox to emit an <code>fyl2x</code> instruction. You could try to work around that by triggering off an instruction you can easily get a JavaScript engine to emit (like an <code>fadd</code>). The problem with that is that if you patch an add instruction and add some checks to it, it will become noticeably slower (although, if you can edit the hardware, you should be able to do it with no overhead). It might be possible to create something hard to detect that's triggerable through JavaScript by patching a <a href=http://www.csc.depauw.edu/~bhoward/asmtut/asmtut7.html>rep string</a> instruction and doing some stuff to set up the appropriate “key” followed by a block copy, or maybe <code>idiv</code>. Alternately, if you've managed to get a copy of the design, you can probably figure out a way to use debug logic triggers<sup class=footnote-ref id=fnref:D><a rel=footnote href=#fn:D>2</a></sup> or performance counters to set off a backdoor when some arbitrary JavaScript gets run.</p> <p>Alright, now you've got a backdoor. How do you insert the backdoor? In software, you'd either edit the source or the <a href=//danluu.com/edit-binary/ >binary</a>. In hardware, if you have access to the source, you can edit it as easily as you can in software. The hardware equivalent of recompiling the source, creating physical chips, has tremendously high fixed costs; if you're trying to get your changes into the source, you'll want to either compromise the design<sup class=footnote-ref id=fnref:A><a rel=footnote href=#fn:A>3</a></sup> and insert your edits before everything is sent off to get manufactured, or compromise the manufacturing process and sneak in your edits at the last second<sup class=footnote-ref id=fnref:E><a rel=footnote href=#fn:E>4</a></sup>.</p> <p>If that sounds too hard, you could try compromising the patch mechanism. Most modern CPUs come with a built-in patch mechanism to allow bug fixes after the fact. It's likely that the CPU you're using has been patched, possibly from day one, and possibly as part of a firmware update. The details of the patch mechanism for your CPU are a closely guarded secret. It's likely that the CPU has a public key etched into it, and that it will only accept a patch that's been signed by the right private key.</p> <p>Is this actually happening? I have no idea. Could it be happening? Absolutely. What are the odds? Well, the primary challenge is non-technical, so I'm not the right person to ask about that. If I had to guess, I'd say no, if for no other reason than the <a href=https://github.com/elvanderb/TCP-32764>ease of subverting other equipment</a>.</p> <p><small> I haven't discussed how to make a backdoor that's hard to detect even if someone has access to software you've used to trigger a backdoor. That's harder, but it should be possible once chips start coming with built-in <a href=http://en.wikipedia.org/wiki/Trusted_Platform_Module>TPMs</a>.</small></p> <p><strong>If you liked this post, you'll probably enjoy <a href=//danluu.com/cpu-bugs/ >this post on CPU bugs</a> and might be interested in <a href=//danluu.com/new-cpu-features/ >this post about new CPU features over the past 35 years</a>.</strong></p> <h4 id=updates>Updates</h4> <p>See <a href=https://twitter.com/danluu/status/562962211782815746>this twitter thread</a> for much more discussion, some of which is summarized below.</p> <p>I'm not going to provide individual attributions because there are too many comments, but here's a summary of comments from @hackerfantastic, Arrigo Triulzi, David Kanter, @solardiz, @4Dgifts, Alfredo Ortega, Marsh Ray, and Russ Cox. Mistakes are my own, of course.</p> <p><a href="http://www.realworldtech.com/forum/?threadid=35566&amp;curpostid=35566">AMD's K7 and K8 had their microcode patch mechanisms compromised</a>, allowing for the sort of attacks mentioned in this post. Turns out, AMD didn't encrypt updates or validate them with a checksum, which lets you easily modify updates until you get one that does what you want.</p> <p><a href=http://es.slideshare.net/ortegaalfredo/deep-submicronbackdoorsortegasyscan2014slides>Here's an example of a backdoor that was created for demonstration purposes</a>, by Alfredo Ortega.</p> <p>For folks without a hardware background, <a href=http://media.ccc.de/browse/congress/2013/30C3_-_5443_-_en_-_saal_g_-_201312281830_-_introduction_to_processor_design_-_byterazor.html#video>this talk on how to implement a CPU in VHDL is nice, and it has a section on how to implement a backdoor</a>.</p> <p>Is it possible to backdoor RDRAND by providing bad random results? Yes. I mentioned that in my first draft of this post, but I got rid of it since my impression was that people don't trust RDRAND and mix the results other sources of entropy. That doesn't make a backdoor useless, but it significantly reduces the value.</p> <p>Would it be possible to store and dump AES-NI keys? It's probably infeasible to sneak flash memory onto a chip without anyone noticing, but modern chips have logic analyzer facilities that let you store and dump data. However, access to those is through some secret mechanism and it's not clear how you'd even get access to binaries that would let you reverse engineer their operation. That's in stark contrast to the K8 reverse engineering, which was possible because microcode patches get included in firmware updates.</p> <p>It would be possible to check instruction prefixes for the trigger. x86 lets you put redundant (and contradictory) instruction prefixes on instructions. Which prefixes get used are well defined, so you can add as many prefixes as you want without causing problems (up to the prefix length limit). The issues with this are that it's probably hard to do without sacrificing performance with a microcode patch, the limited number of prefixes and the length limit mean that your effective key size is relatively small if you don't track state across multiple instructions, and that you can only generate the trigger with native code.</p> <p>As far as anyone knows, this is all speculative, and no one has seen an actual CPU backdoor being used in the wild.</p> <h4 id=acknowledgments>Acknowledgments</h4> <p>Thanks to Leah Hanson for extensive comments, to Aleksey Shipilev and Joe Wilder for suggestions/corrections, and to the many participants in the twitter discussion linked to above. Also, thanks to Markus Siemens for noticing that a bug in some RSS readers was causing problems, and for providing the workaround. That's not really specific to this post, but it happened to come up here. </p> <div class=footnotes> <hr> <ol> <li id=fn:I><p>This choice of instruction is somewhat, but not completely, arbitrary. You'll probably want an instruction that's both slow and microcoded, to make it easy to patch with a microcode patch without causing a huge performance hit. The rest of this footnote is about what it means for an instruction to be microcoded. It's quite long and not in the critical path of this post, so you might want to skip it.</p> <p>The distinction between a microcoded instruction and one that's implemented in hardware is, itself, somewhat arbitrary. CPUs have an instruction set they implement, which you can think of as a public API. Internally, they can execute a different instruction set, which you can think of as a private API.</p> <p>On modern Intel chips, instructions that turn into four (or fewer) uops (private API calls) are translated into uops directly by the decoder. Instructions that result in more uops (anywhere from five to hundreds or possibly thousands) are decoded via a microcode engine that reads uops out of a small ROM or RAM on the CPU. Why four and not five? That's a result of some tradeoffs, not some fundamental truth. The terminology for this isn't standardized, but the folks I know would say that an instruction is “microcoded” if its decode is handled by the microcode engine and that it's “implemented in hardware” if its decode is handled by the standard decoder. The microcode engine is sort of its own CPU, since it has to be able to handle things like reading and writing from temporary registers that aren't architecturally visible, reading and writing from internal RAM for instructions that need more than just a few registers of scratch space, conditional microcode branches that change which microcode the microcode engine fetches and decodes, etc.</p> <p>Implementation details vary (and tend to be secret). But whatever the implementation, you can think of the microcode engine as something that loads a RAM with microcode when the CPU starts up, which then fetches and decodes microcoded instructions out of that RAM. It's easy to modify what microcode gets executed by changing what gets loaded on boot via a microcode patch.</p> <p>For quicker turnaround while debugging, it's somewhere between plausible and likely that Intel also has a mechanism that lets them force non-microcoded instructions to execute out of the microcode RAM in order to allow them to be patched with a microcode patch. But even if that's not the case, compromising the microcode patch mechanism and modifying a single microcoded instruction should be sufficient to install a backdoor.</p> <a class=footnote-return href=#fnref:I><sup>[return]</sup></a></li> <li id=fn:D>For the most part, these aren't publicly documented, but you can get a high-level overview of what kind of debug triggers Intel was building into their chips a couple generators ago starting at page 128 of <a href=http://click.intel.com/the-tick-tock-beat-of-microprocessor-development-at-intel.html>Intel Technology Journal, Volume 4, Issue 3</a>. <a class=footnote-return href=#fnref:D><sup>[return]</sup></a></li> <li id=fn:A>For the past couple years, there's been a debate over whether or not major corporations have been compromised and whether such a thing is even possible. During the cold war, government agencies on all sides were compromised at various levels for extended periods of time, despite having access to countermeasures not available to any corporations today (not hiring citizens of foreign countries, &quot;enhanced interrogation techniques&quot;, etc.). I'm not sure that we'll ever know if companies are being compromised, but it would certainly be easier to compromise a present-day corporation than it was to compromise government agencies during the cold war, and that was eminently doable. Compromising a company enough to get the key to the microcode patch is trivial compared to what was done during the cold war. <a class=footnote-return href=#fnref:A><sup>[return]</sup></a></li> <li id=fn:E><p>This is another really long footnote about minutia! In particular, it's about the manufacturing process. You might want to skip it! If you don't, don't say I didn't warn you.</p> <p>It turns out that editing chips before manufacturing is fully complete is relatively easy, by design. To explain why, we'll have to look at how chips are made.</p> <p><img src=/images/cpu-backdoors/intel_22nm.png alt="Cross section of Intel chip, 22nm process"width=420 height=440></p> <p>When you look at a <a href=http://www.intel.com/content/dam/www/public/us/en/documents/presentation/silicon-technology-leadership-presentation.pdf>cross-section of a chip</a>, you see that silicon gates are at the bottom, forming logical primitives like <a href=http://www.nand2tetris.org/ >nand gates</a>, with a series of metal layers above (labeled M1 through M8), forming wires that connect different gates. A cartoon model of the manufacturing process is that chips are built from the bottom up, one layer a time, where each layer is created by depositing some material and then etching part of it away using a mask, in a process that's analogous to <a href=http://en.wikipedia.org/wiki/Lithography>lithographic printing</a>. The non-cartoon version involves a lot of complexity -- <a href="https://www.youtube.com/watch?v=NGFhc8R_uO4">Todd Fernendez estimates that it takes about 500 steps to create the layers below “M1”</a>. Additionally, the level of precision needed is high enough that the light used to etch causes enough wear in the equipment that it wears out. You probably don't normally think about lenses wearing out due to light passing through them, but at the level of precision required for each of the hundreds of steps required to make a transistor, it's a serious problem. If that sounds surprising to you, you're not alone. An <a href=http://www.itrs.net/ >ITRS roadmap</a> from the 90s predicted that by 2016, we'd be at almost 30GHz (higher is better) on a 9nm process (smaller is better), with chips consuming almost 300 watts. Instead, 5 GHz is considered pretty fast, and anyone who isn't Intel will be lucky to get high-yield production on a 14nm process by the start of 2016. Making chips is harder than anyone guessed it would be.</p> <p>A modern chip has enough layers that it takes about three months to make one, from start to finish. This makes bugs very bad news since a bug fix that requires a change to one of the bottom layers takes three months to manufacture. In order to reduce the turnaround time on bug fixes, it's typical to scatter unused logic gates around the silicon, to allow small bug fixes to be done with an edit to a few layers that are near the top. Since chips are made in a manufacturing line process, at any point in time, there are batches of partially complete chips. If you only need to edit one of the top metal layers, you can apply the edit to a partially finished chip, cutting the turnaround time down from months to weeks.</p> <p>Since chips are designed to allow easy edits, someone with access to the design before the chip is manufactured (such as the manufacturer) can make major changes with relatively small edits. I suspect that if you were to make this comment to anyone at a major CPU company, they'd tell you it's impossible to do this without them noticing because it would get caught in characterization or when they were trying to find speed paths or something similar. One would hope, but <a href=http://www.cl.cam.ac.uk/~sps32/sec_news.html#Assurance>actual hardware devices have shipped with backdoors</a>, and either no one noticed, or they were complicit.</p> <a class=footnote-return href=#fnref:E><sup>[return]</sup></a></li> </ol> </div> </main><nav><div class=np> <a href=customer-service/ >← AI doesn&#39;t have to be very good to displace humans</a> <a href=blog-ads/ >Blog monetization →</a> </div></nav> <footer><div class=np> <a href= >Archive</a> <a href=https://mastodon.social/@danluu>Mastodon</a> <a href=https://threads.net/@danluu.danluu>Threads</a> </div> <div class=np> <a href=https://www.patreon.com/danluu>Patreon</a> <a href=https://www.linkedin.com/in/danluu/ >LinkedIn</a> <a href=https://twitter.com/danluu/ >Twitter</a> <a href=atom.xml>RSS</a></div></footer> 