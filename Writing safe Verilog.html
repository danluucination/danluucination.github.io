<!doctypehtml><html lang=en><meta charset=utf-8><title>Writing safe Verilog</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="stylesheet" href="/styles.css"></style><link rel=icon href="data:;base64,="> <header><strong>Writing safe Verilog</strong> | <i><b><a href=https://patreon.com/danluu>I'm trying some experimental tiers on Patreon</a></b> to see if I can get to <a href=https://twitter.com/danluu/status/1456346963691991041>substack-like levels of financial support for this blog without moving to substack</a>!</i><hr></header><main> <p><img src=/images/pl-troll/davidalbert-pl-troll.png alt="PL troll: a statically typed language with no type declarations. Types are determined entirely using Hungarian notation"width=1160 height=448></p> <p>Troll? That's how people write Verilog<sup class=footnote-ref id=fnref:1><a rel=footnote href=#fn:1>1</a></sup>. At my old company, we had a team of formal methods PhD's who wrote a linter that typechecked our code, based on our naming convention. For our chip (which was small for a CPU), building a model (compiling) took about five minutes, running a single short test took ten to fifteen minutes, and long tests took CPU months. The value of a linter that can run in seconds should be obvious, not even considering the fact that it can take hours of tracing through waveforms to find out why a test failed<sup class=footnote-ref id=fnref:2><a rel=footnote href=#fn:2>2</a></sup>.</p> <p>Lets look at some of the most commonly used naming conventions.</p>  <h3 id=pipeline-stage>Pipeline stage</h3> <p>When you <a href=http://en.wikipedia.org/wiki/Pipeline_(computing)>pipeline</a> hardware, you end up with many versions of the same signal, one for each stage of the pipeline the signal traverses. Even without static checks, you'll want some simple way to differentiate between these, so you might name them <code>foo_s1</code>, <code>foo_s2</code>, and <code>foo_s3</code>, indicating that they originate in the first, second, and third stages, respectively. In any particular stage, a signal is most likely to interact with other signals in the same stage; it's often a mistake when logic from other stages is accessed. There are reasons to access signals from other stages, like bypass paths and control logic that looks at multiple stages, but logic that stays contained within a stage is common enough that it's not too tedious to either “cast” or add a comment that disables the check, when looking at signals from other stages.</p> <h3 id=clock-domain>Clock domain</h3> <p>Accessing a signal in a different clock domain without synchronization is like accessing a data structure from multiple threads without synchronization. Sort of. But worse. Much worse. Driving combinational logic from a metastable state (where the signal is sitting between a 0 and 1) can burn a massive amount of power<sup class=footnote-ref id=fnref:3><a rel=footnote href=#fn:3>3</a></sup>. Here, I'm not just talking about being inefficient. If you took a high-power chip from the late 90s and removed the heat sink, it would melt itself into the socket, even under normal operation. Modern chips have such a high maximum power possible power consumption that the chips would self destruct if you disabled the thermal regulation, even with the heat sink. Logic that's floating at an intermediate value not only uses a lot of power, it bypasses a chip's usual ability to reduce power by slowing down the clock<sup class=footnote-ref id=fnref:4><a rel=footnote href=#fn:4>4</a></sup>. Using cross clock domain signals without synchronization is a bad idea, unless you like random errors, high power dissipation, and the occasional literal meltdown.</p> <h3 id=module-region>Module / Region</h3> <p>In high speed designs, it's an error to use a signal that's sourced from another module without registering it first. This will insidiously sneak through simulation; you'll only notice when you look at the timing report. On the last chip I worked on, it took about two days to generate a timing report<sup class=footnote-ref id=fnref:and-you-couldn-t-concurrently-generate-a-new-one-for-each-build-due-to-the-license-costs-6><a rel=footnote href=#fn:and-you-couldn-t-concurrently-generate-a-new-one-for-each-build-due-to-the-license-costs-6>0</a></sup>. If you accidentally reference a signal from a distant module, not only will you not meet your timing budget for that path, the synthesis tool will allocate resources to try to make that path faster, which will slow down everything else<sup class=footnote-ref id=fnref:7><a rel=footnote href=#fn:7>5</a></sup>, making the entire timing report worthless<sup class=footnote-ref id=fnref:9><a rel=footnote href=#fn:9>6</a></sup>.</p> <h3 id=pl-trolling>PL Trolling</h3> <p>I'd been feeling naked at my new gig, coding Verilog without any sort of static checking. I put off writing my own checker, because static analysis is one of those scary things you need a PhD to do, right? And writing a parser for SystemVerilog is a ridiculously large task<sup class=footnote-ref id=fnref:10><a rel=footnote href=#fn:10>7</a></sup>. But, it turns out that don't need much of a parser, and all the things I've talked about are simple enough that half an hour after starting, I had a tool that found seven bugs, with only two false positives. I expect we'll have 4x as much code by the time we're done, so that's 28 bugs from half an hour of work, not even considering the fact that two of the bugs were in heavily used macros.</p> <p>I think I'm done for the day, but there are plenty of other easy things to check that will certainly find bugs (e.g, checking for regs/logic that are declared or assigned, but not used). Whenever I feel like tackling a self-contained challenge, there are plenty of not-so-easy things, too (e.g., checking if things aren't clock gated or power gated when they should be, which isn't hard to do statistically, but is non-trivial statically).</p> <p>Huh. That wasn't so bad. I've now graduated to junior PL troll.</p> <div class=footnotes> <hr> <ol> <li id=fn:1>Well, people usually use suffixes as well as prefixes. <a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li> <li id=fn:2>You should, of course, write your own tool to script interaction with your waveform view because waveform viewers have such poor interfaces, but that's whole ‘nother blog post. <a class=footnote-return href=#fnref:2><sup>[return]</sup></a></li> <li id=fn:3>In <a href=http://en.wikipedia.org/wiki/CMOS>static CMOS</a> there's a network of transistors between power and output, and a dual network between ground and output. As a first-order approximation, only one of the two networks should be on at a time, except when switching, which is why switching logic gates use power than unchanging gates -- in addition to the power used to discharge the capacitance that the output is driving, there is, briefly, a direct connection from power to ground. If you get stuck into a half-on state, there's a constant connection from power to ground. <a class=footnote-return href=#fnref:3><sup>[return]</sup></a></li> <li id=fn:4>In theory, power gating could help, but you can't just power gate some arbitrary part of the chip that's too hot. <a class=footnote-return href=#fnref:4><sup>[return]</sup></a></li> <li id=fn:7>There are a number of reasons that this completely destroys the timing report. First, for any high-speed design, there's not enough fast (wide) interconnect to go around. Gates are at the bottom, and wires sit above them. Wires get wider and faster in higher layers, but there's congestion getting to and from the fast wires, and relatively few of them. There are so few of them that people pre-plan where modules should be placed in order to have enough fast interconnect to meet timing demands. If you steal some fast wires to make some slow path fast, anything relying on having a fast path through that region is hosed. Second, the synthesis tool tries to place sources near sinks, to reduce both congestion and delay. If you place a sink on a net that's very far from the rest of the sinks, the source will migrate halfway in between, to try to match the demands of all the sinks. This is recursively bad, and will pull all the second order sources away from their optimal location, and so on and so forth. <a class=footnote-return href=#fnref:7><sup>[return]</sup></a></li> <li id=fn:9>With some tools, you can have them avoid optimizing paths that fail timing by more than a certain margin, but there's still always some window where a bad path will destroy your entire timing report, and it's often the case that there are real critical paths that need all the resources the synthesis tool can throw at it to make it across the chip in time. <a class=footnote-return href=#fnref:9><sup>[return]</sup></a></li> <li id=fn:10>The SV standard is 1300 pages long, vs 800 for C++, 500 for C, 300 for Java, and 30 for Erlang. <a class=footnote-return href=#fnref:10><sup>[return]</sup></a></li> </ol> </div> </main><nav><div class=np> <a href=danluucination.github.io/randomize-hn/ >← Randomize HN</a> <a href=danluucination.github.io/why-hardware-development-is-hard/ >Verilog is weird →</a> </div> <div class=np> <a href=danluucination.github.io/ >Archive</a> <a href=https://www.patreon.com/danluu>Patreon</a> <a href=https://mastodon.social/@danluu>Mastodon</a> <a href=https://threads.net/@danluu.danluu>Threads</a> </div></nav>